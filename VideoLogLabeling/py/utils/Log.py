import glob
import json
import os
import re

from py.parsers import BehaviorParser
from .Config import config


class Log:

    def __init__(self, game, dir, data_dir):
        self.game = game
        self.directory = dir
        self.data_directory = data_dir

        self.file = None
        self.sync_file = None
        self.labels = []
        self.labels_data = None

        self.player_number = 0
        self.nao = None
        self.robot = None

        self.parse_info()
        self.scan_data()

    def parse_info(self):
        log_file = os.path.join(self.directory, config['log']['name'])
        if os.path.isfile(log_file):
            self.file = log_file

        m = re.match(config['log']['regex'], os.path.basename(self.directory))

        self.player_number = m.group(1)
        self.nao = m.group(2)
        self.robot = m.group(3)

    def scan_data(self):
        if os.path.isdir(self.data_directory):
            # set the sync information
            sync_file = os.path.join(self.data_directory, config['log']['sync'])
            if os.path.isfile(sync_file):
                self.sync_file = { 'file': sync_file }
                # TODO: parse this file

            self.labels = glob.glob(self.data_directory+'/'+config['log']['labels'][0]+'*'+config['log']['labels'][1])
            # TODO: parse labels ?

    def __read_labels(self):
        if self.labels_data is None:
            label_file = self.data_directory+'/'+config['log']['labels'][0]+config['log']['labels'][1]
            if os.path.isfile(label_file):
                self.labels_data = json.load(open(label_file, 'r'), 'utf-8')

        return self.labels_data

    def parsed_actions(self):
        data = self.__read_labels()
        if data and 'parsed_actions' in data:
            return data['parsed_actions']
        return []

    def has_syncing_file(self):
        return self.sync_file is not None

    def create_default_syncing_file(self):
        print(self.directory, self.data_directory, self.file)
        if self.file:
            point = self.find_first_ready_state(self.file)
            if point:
                self.sync_file = os.path.join(self.data_directory, config['log']['sync'])
                with open(self.sync_file, 'w') as sf:
                    sf.writelines([
                        '# generated by python script\n'
                        'sync-time-video=0.0\n',
                        'sync-time-log='+str(point[1]/1000.0)+'\n',
                        'video-file='+(self.game.videos[0] if self.game.videos else '')+'\n'
                    ])

    def find_first_ready_state(self, file):
        parser = BehaviorParser.BehaviorParser()
        log = BehaviorParser.LogReader(file, parser)

        for frame in log:
            if 'BehaviorStateComplete' in frame.messages:
                m, o = frame["BehaviorStateComplete"]
            else:
                m, o = frame["BehaviorStateSparse"]

            if m['game.state'] == 1:
                return frame.number, frame['FrameInfo'].time

        return None

    def has_label_file(self):
        return len(self.labels) > 0

    def create_label_file(self, actions):
        # print(self.directory, self.data_directory, self.file)
        parser = BehaviorParser.BehaviorParser()
        log = BehaviorParser.LogReader(self.file, parser)
        data = { 'parsed_actions': actions.keys(), 'intervals': [] }

        # enforce the whole log being parsed (this is necessary for older game logs)
        for frame in log:
            s, o = (None, None)
            if "BehaviorStateComplete" in frame.messages:
                s, o = frame["BehaviorStateComplete"]
            if "BehaviorStateSparse" in frame.messages:
                s, o = frame["BehaviorStateSparse"]
            # enforce parsing FrameInfo
            fi = frame["FrameInfo"]

            # got valid data
            if s and o:
                for a in actions:
                    if actions[a](s, o):
                        # TODO: how to find the start/begin of the interval??
                        '''
                        pose = {"x": begin_data[2], "y": begin_data[3], "r": begin_data[4]}
                        ball = {"x": begin_data[5], "y": begin_data[6]}
                        t_begin = begin_data[0] * 60
                        t_end = end_data[0] * 60
                        type = begin_data[1]

                        intervals.append({"type": type, "begin": t_begin, "end": t_end, "pose": pose, "ball": ball})
                        return [frame["FrameInfo"].time / (1000.0 * 60), action,
                                m["robot_pose.x"], m["robot_pose.y"], m["robot_pose.rotation"] * math.pi / 180,
                                m["ball.position.field.x"], m["ball.position.field.y"]]
                        '''

        label_file = self.data_directory + '/' + config['log']['labels'][0] + config['log']['labels'][1]
        #json.dump(data, open(label_file, 'w'), indent=4, separators=(',', ': '))
        print(label_file, data)


    def __repr__(self):
        return "Nao{} #{}".format(self.nao, self.player_number)
